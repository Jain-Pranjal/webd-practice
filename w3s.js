// here i will be reading and implementing from the doc
console.log(Date());
// where do we need to link the js ?
// at the above last of the body 

// so we can add the evenet listener as 
// document.getElementById("fds").addEventListener("any event that can takes place ",(e)=>{
//     document.getElementById("fds").innerHTML=nfjsnd
// })


a=5
console.log(a);


// hoisting
// Variables defined with var are hoisted to the top and can be initialized at any time.
// Mean oisted 

class animal{
    "run"=true
    name="sheru"
    age=54
    location="delhi"
}

let hello=new animal()


// String length
// String slice()
// String substring()
// String substr()
// String replace()
// String replaceAll()
// String toUpperCase()
// String toLowerCase()
// String concat()
// String trim()
// String trimStart()
// String trimEnd()
// String padStart()
// String padEnd()
// String charAt()
// String charCodeAt()
// String split()

// This operator
/*The handling of this is also different in arrow functions compared to regular functions.

In short, with arrow functions there are no binding of this.

In regular functions the this keyword represented the object that called the function, which could be the window, the document, a button or whatever.

With arrow functions the this keyword always represents the object that defined the arrow function.

Let us take a look at two examples to understand the difference.

Both examples call a method twice, first when the page loads, and once again when the user clicks a button.

The first example uses a regular function, and the second example uses an arrow function.

The result shows that the first example returns two different objects (window and button), and the second example returns the window object twice, because the window object is the "owner" of the function.


 */





























